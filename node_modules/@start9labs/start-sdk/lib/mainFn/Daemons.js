import { defaultTrigger } from "../health/trigger/defaultTrigger";
/**
 * A class for defining and controlling the service daemons
```ts
Daemons.of({
  effects,
  started,
  interfaceReceipt, // Provide the interfaceReceipt to prove it was completed
  healthReceipts, // Provide the healthReceipts or [] to prove they were at least considered
}).addDaemon('webui', {
  command: 'hello-world', // The command to start the daemon
  ready: {
    display: 'Web Interface',
    // The function to run to determine the health status of the daemon
    fn: () =>
      checkPortListening(effects, 80, {
        successMessage: 'The web interface is ready',
        errorMessage: 'The web interface is not ready',
      }),
  },
  requires: [],
})
```
 */
export class Daemons {
    effects;
    started;
    daemons;
    constructor(effects, started, daemons) {
        this.effects = effects;
        this.started = started;
        this.daemons = daemons;
    }
    /**
     * Returns an empty new Daemons class with the provided config.
     *
     * Call .addDaemon() on the returned class to add a daemon.
     *
     * Daemons run in the order they are defined, with latter daemons being capable of
     * depending on prior daemons
     * @param config
     * @returns
     */
    static of(config) {
        return new Daemons(config.effects, config.started);
    }
    /**
     * Returns the complete list of daemons, including the one defined here
     * @param id
     * @param newDaemon
     * @returns
     */
    addDaemon(
    // prettier-ignore
    id, newDaemon) {
        const daemons = (this?.daemons ?? []).concat({
            ...newDaemon,
            id,
        });
        return new Daemons(this.effects, this.started, daemons);
    }
    async build() {
        const daemonsStarted = {};
        const { effects } = this;
        const daemons = this.daemons ?? [];
        for (const daemon of daemons) {
            const requiredPromise = Promise.all(daemon.requires?.map((id) => daemonsStarted[id]) ?? []);
            daemonsStarted[daemon.id] = requiredPromise.then(async () => {
                const { command } = daemon;
                const child = effects.runDaemon(command, { env: daemon.env });
                let currentInput = {};
                const getCurrentInput = () => currentInput;
                const trigger = (daemon.ready.trigger ?? defaultTrigger)(getCurrentInput);
                return new Promise(async (resolve) => {
                    for (let res = await trigger.next(); !res.done; res = await trigger.next()) {
                        const response = await Promise.resolve(daemon.ready.fn()).catch((err) => ({
                            status: "failing",
                            message: "message" in err ? err.message : String(err),
                        }));
                        currentInput.lastResult = response.status || null;
                        if (!currentInput.hadSuccess && response.status === "passing") {
                            currentInput.hadSuccess = true;
                            resolve(child);
                        }
                    }
                    resolve(child);
                });
            });
        }
        return {
            async term() {
                await Promise.all(Object.values(daemonsStarted).map((x) => x.then((x) => x.term())));
            },
            async wait() {
                await Promise.all(Object.values(daemonsStarted).map((x) => x.then((x) => x.wait())));
            },
        };
    }
}
