import { Parser } from "ts-matches";
import * as T from "../types";
import FileHelper from "./fileHelper";
import nullIfEmpty from "./nullIfEmpty";
import { GetWrapperData } from "./getWrapperData";
import { CheckResult } from "../health/checkFns";
import { ExtractWrapperData } from "../types";
import { GetSystemSmtp } from "./GetSystemSmtp";
import "./nullIfEmpty";
import "./fileHelper";
import "./getWrapperData";
import "./deepEqual";
import "./deepMerge";
import "./once";
import { LocalBinding } from "../mainFn/LocalBinding";
import { NetworkBuilder } from "../mainFn/NetworkBuilder";
import { TorHostname } from "../mainFn/TorHostname";
export type FlattenIntersection<T> = T extends ArrayLike<any> ? T : T extends object ? {} & {
    [P in keyof T]: T[P];
} : T;
export type _<T> = FlattenIntersection<T>;
/** Used to check if the file exists before hand */
export declare const exists: (effects: T.Effects, props: {
    path: string;
    volumeId: string;
}) => Promise<boolean>;
export declare const isKnownError: (e: unknown) => e is T.KnownError;
declare const affine: unique symbol;
export type WrapperDataOptionals<WrapperData, Path extends string> = {
    validator?: Parser<unknown, ExtractWrapperData<WrapperData, Path>>;
    /** Defaults to what ever the package currently in */
    packageId?: string | undefined;
};
export type Utils<WD, WrapperOverWrite = {
    const: never;
}> = {
    readFile: <A>(fileHelper: FileHelper<A>) => ReturnType<FileHelper<A>["read"]>;
    writeFile: <A>(fileHelper: FileHelper<A>, data: A) => ReturnType<FileHelper<A>["write"]>;
    getSystemSmtp: () => GetSystemSmtp & WrapperOverWrite;
    getWrapperData: <Path extends string>(packageId: string, path: T.EnsureWrapperDataPath<WD, Path>) => GetWrapperData<WD, Path> & WrapperOverWrite;
    getOwnWrapperData: <Path extends string>(path: T.EnsureWrapperDataPath<WD, Path>) => GetWrapperData<WD, Path> & WrapperOverWrite;
    setOwnWrapperData: <Path extends string | never>(path: T.EnsureWrapperDataPath<WD, Path>, value: ExtractWrapperData<WD, Path>) => Promise<void>;
    checkPortListening(port: number, options: {
        errorMessage: string;
        successMessage: string;
        timeoutMessage?: string;
        timeout?: number;
    }): Promise<CheckResult>;
    checkWebUrl(url: string, options?: {
        timeout?: number;
        successMessage?: string;
        errorMessage?: string;
    }): Promise<CheckResult>;
    bindLan: (port: number) => Promise<LocalBinding>;
    networkBuilder: () => NetworkBuilder;
    torHostName: (id: string) => TorHostname;
    exists: (props: {
        path: string;
        volumeId: string;
    }) => Promise<boolean>;
    nullIfEmpty: typeof nullIfEmpty;
};
export declare const utils: <WrapperData = never, WrapperOverWrite = {
    const: never;
}>(effects: T.Effects) => Utils<WrapperData, WrapperOverWrite>;
type NeverPossible = {
    [affine]: string;
};
export type NoAny<A> = NeverPossible extends A ? keyof NeverPossible extends keyof A ? never : A : A;
export {};
