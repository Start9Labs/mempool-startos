import * as matches from "ts-matches";
import * as T from "../types";
/**
 * Used in the get config and the set config exported functions.
 * The idea is that we are going to be reading/ writing to a file, or multiple files. And then we use this tool
 * to keep the same path on the read and write, and have methods for helping with structured data.
 * And if we are not using a structured data, we can use the raw method which forces the construction of a BiMap
 * ```ts
        import {InputSpec} from './InputSpec.ts'
        import {matches, T} from '../deps.ts';
        const { object, string, number, boolean, arrayOf, array, anyOf, allOf } = matches
        const someValidator = object({
        data: string
        })
        const jsonFile = FileHelper.json({
        path: 'data.json',
        validator: someValidator,
        volume: 'main'
        })
        const  tomlFile = FileHelper.toml({
        path: 'data.toml',
        validator: someValidator,
        volume: 'main'
        })
        const rawFile = FileHelper.raw({
        path: 'data.amazingSettings',
        volume: 'main'
        fromData(dataIn: Data): string {
            return `myDatais ///- ${dataIn.data}`
        },
        toData(rawData: string): Data {
        const [,data] = /myDatais \/\/\/- (.*)/.match(rawData)
        return {data}
        }
        })

        export const setConfig : T.ExpectedExports.setConfig= async (effects, config) => {
        await  jsonFile.write({ data: 'here lies data'}, effects)
        }

        export const getConfig: T.ExpectedExports.getConfig = async (effects, config) => ({
        spec: InputSpec,
        config: nullIfEmpty({
            ...jsonFile.get(effects)
        })
    ```
 */
export declare class FileHelper<A> {
    readonly path: string;
    readonly volume: string;
    readonly writeData: (dataIn: A) => string;
    readonly readData: (stringValue: string) => A;
    protected constructor(path: string, volume: string, writeData: (dataIn: A) => string, readData: (stringValue: string) => A);
    write(data: A, effects: T.Effects): Promise<void>;
    read(effects: T.Effects): Promise<A | null>;
    /**
     * Create a File Helper for an arbitrary file type.
     *
     * Provide custom functions for translating data to the file format and visa versa.
     */
    static raw<A>(path: string, volume: string, toFile: (dataIn: A) => string, fromFile: (rawData: string) => A): FileHelper<A>;
    /**
     * Create a File Helper for a .json file
     */
    static json<A>(path: string, volume: string, shape: matches.Validator<unknown, A>): FileHelper<A>;
    /**
     * Create a File Helper for a .toml file
     */
    static toml<A extends Record<string, unknown>>(path: string, volume: string, shape: matches.Validator<unknown, A>): FileHelper<A>;
    /**
     * Create a File Helper for a .yaml file
     */
    static yaml<A extends Record<string, unknown>>(path: string, volume: string, shape: matches.Validator<unknown, A>): FileHelper<A>;
}
export default FileHelper;
