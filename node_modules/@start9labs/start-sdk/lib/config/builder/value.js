import { Config } from "./config";
import { Variants } from "./variants";
import { anyOf, arrayOf, boolean, literal, literals, number, object, string, unknown, } from "ts-matches";
import { once } from "../../util/once";
function requiredLikeToAbove(requiredLike) {
    // prettier-ignore
    return {
        required: (typeof requiredLike === 'object' ? true : requiredLike),
        default: (typeof requiredLike === 'object' ? requiredLike.default : null)
    };
}
const testForAsRequiredParser = once(() => object({ required: object({ default: unknown }) }).test);
function asRequiredParser(parser, input) {
    if (testForAsRequiredParser()(input))
        return parser;
    return parser.optional();
}
/**
 * A value is going to be part of the form in the FE of the OS.
 * Something like a boolean, a string, a number, etc.
 * in the fe it will ask for the name of value, and use the rest of the value to determine how to render it.
 * While writing with a value, you will start with `Value.` then let the IDE suggest the rest.
 * for things like string, the options are going to be in {}.
 * Keep an eye out for another config builder types as params.
 * Note, usually this is going to be used in a `Config` {@link Config} builder.
 ```ts
const username = Value.string({
  name: "Username",
  default: "bitcoin",
  description: "The username for connecting to Bitcoin over RPC.",
  warning: null,
  required: true,
  masked: true,
  placeholder: null,
  pattern: "^[a-zA-Z0-9_]+$",
  patternDescription: "Must be alphanumeric (can contain underscore).",
});
 ```
 */
export class Value {
    build;
    validator;
    constructor(build, validator) {
        this.build = build;
        this.validator = validator;
    }
    static toggle(a) {
        return new Value(async () => ({
            description: null,
            warning: null,
            default: null,
            type: "toggle",
            disabled: false,
            immutable: a.immutable ?? false,
            ...a,
        }), boolean);
    }
    static dynamicToggle(a) {
        return new Value(async (options) => ({
            description: null,
            warning: null,
            default: null,
            type: "toggle",
            disabled: false,
            immutable: false,
            ...(await a(options)),
        }), boolean);
    }
    static text(a) {
        return new Value(async () => ({
            type: "text",
            description: null,
            warning: null,
            masked: false,
            placeholder: null,
            minLength: null,
            maxLength: null,
            patterns: [],
            inputmode: "text",
            disabled: false,
            immutable: a.immutable ?? false,
            ...a,
            ...requiredLikeToAbove(a.required),
        }), asRequiredParser(string, a));
    }
    static dynamicText(getA) {
        return new Value(async (options) => {
            const a = await getA(options);
            return {
                type: "text",
                description: null,
                warning: null,
                masked: false,
                placeholder: null,
                minLength: null,
                maxLength: null,
                patterns: [],
                inputmode: "text",
                disabled: false,
                immutable: false,
                ...a,
                ...requiredLikeToAbove(a.required),
            };
        }, string.optional());
    }
    static textarea(a) {
        return new Value(async () => ({
            description: null,
            warning: null,
            minLength: null,
            maxLength: null,
            placeholder: null,
            type: "textarea",
            disabled: false,
            immutable: a.immutable ?? false,
            ...a,
        }), string);
    }
    static dynamicTextarea(getA) {
        return new Value(async (options) => {
            const a = await getA(options);
            return {
                description: null,
                warning: null,
                minLength: null,
                maxLength: null,
                placeholder: null,
                type: "textarea",
                disabled: false,
                immutable: false,
                ...a,
            };
        }, string);
    }
    static number(a) {
        return new Value(() => ({
            type: "number",
            description: null,
            warning: null,
            min: null,
            max: null,
            step: null,
            units: null,
            placeholder: null,
            disabled: false,
            immutable: a.immutable ?? false,
            ...a,
            ...requiredLikeToAbove(a.required),
        }), asRequiredParser(number, a));
    }
    static dynamicNumber(getA) {
        return new Value(async (options) => {
            const a = await getA(options);
            return {
                type: "number",
                description: null,
                warning: null,
                min: null,
                max: null,
                step: null,
                units: null,
                placeholder: null,
                disabled: false,
                immutable: false,
                ...a,
                ...requiredLikeToAbove(a.required),
            };
        }, number.optional());
    }
    static color(a) {
        return new Value(() => ({
            type: "color",
            description: null,
            warning: null,
            disabled: false,
            immutable: a.immutable ?? false,
            ...a,
            ...requiredLikeToAbove(a.required),
        }), asRequiredParser(string, a));
    }
    static dynamicColor(getA) {
        return new Value(async (options) => {
            const a = await getA(options);
            return {
                type: "color",
                description: null,
                warning: null,
                disabled: false,
                immutable: false,
                ...a,
                ...requiredLikeToAbove(a.required),
            };
        }, string.optional());
    }
    static datetime(a) {
        return new Value(() => ({
            type: "datetime",
            description: null,
            warning: null,
            inputmode: "datetime-local",
            min: null,
            max: null,
            step: null,
            disabled: false,
            immutable: a.immutable ?? false,
            ...a,
            ...requiredLikeToAbove(a.required),
        }), asRequiredParser(string, a));
    }
    static dynamicDatetime(getA) {
        return new Value(async (options) => {
            const a = await getA(options);
            return {
                type: "datetime",
                description: null,
                warning: null,
                inputmode: "datetime-local",
                min: null,
                max: null,
                step: null,
                disabled: false,
                immutable: false,
                ...a,
                ...requiredLikeToAbove(a.required),
            };
        }, string.optional());
    }
    static select(a) {
        return new Value(() => ({
            description: null,
            warning: null,
            type: "select",
            disabled: false,
            immutable: a.immutable ?? false,
            ...a,
            ...requiredLikeToAbove(a.required),
        }), asRequiredParser(anyOf(...Object.keys(a.values).map((x) => literal(x))), a));
    }
    static dynamicSelect(getA) {
        return new Value(async (options) => {
            const a = await getA(options);
            return {
                description: null,
                warning: null,
                type: "select",
                disabled: false,
                immutable: false,
                ...a,
                ...requiredLikeToAbove(a.required),
            };
        }, string.optional());
    }
    static multiselect(a) {
        return new Value(() => ({
            type: "multiselect",
            minLength: null,
            maxLength: null,
            warning: null,
            description: null,
            disabled: false,
            immutable: a.immutable ?? false,
            ...a,
        }), arrayOf(literals(...Object.keys(a.values))));
    }
    static dynamicMultiselect(getA) {
        return new Value(async (options) => {
            const a = await getA(options);
            return {
                type: "multiselect",
                minLength: null,
                maxLength: null,
                warning: null,
                description: null,
                disabled: false,
                immutable: false,
                ...a,
            };
        }, arrayOf(string));
    }
    static object(a, previousSpec) {
        return new Value(async (options) => {
            const spec = await previousSpec.build(options);
            return {
                type: "object",
                description: null,
                warning: null,
                ...a,
                spec,
            };
        }, previousSpec.validator);
    }
    static union(a, aVariants) {
        return new Value(async (options) => ({
            type: "union",
            description: null,
            warning: null,
            ...a,
            variants: await aVariants.build(options),
            ...requiredLikeToAbove(a.required),
            immutable: a.immutable ?? false,
        }), asRequiredParser(aVariants.validator, a));
    }
    static filteredUnion(getDisabledFn) {
        return (a, aVariants) => {
            return new Value(async (options) => ({
                type: "union",
                description: null,
                warning: null,
                ...a,
                variants: await aVariants.build(options),
                ...requiredLikeToAbove(a.required),
                disabled: (await getDisabledFn(options)) || [],
                immutable: false,
            }), asRequiredParser(aVariants.validator, a));
        };
    }
    static list(a) {
        return new Value((options) => a.build(options), a.validator);
    }
    /**
     * Use this during the times that the input needs a more specific type.
     * Used in types that the value/ variant/ list/ config is constructed somewhere else.
    ```ts
    const a = Config.text({
      name: "a",
      required: false,
    })
  
    return Config.of<WrapperData>()({
      myValue: a.withWrapperData(),
    })
    ```
     */
    withWrapperData() {
        return this;
    }
}
const valueA = Value.dynamicText(() => ({
    name: "a",
    required: false,
}));
const variantForC = Variants.of({
    lnd: {
        name: "lnd Name",
        spec: Config.of({
            name: Value.text({
                name: "Node Name",
                required: false,
            }),
        }),
    },
});
const valueC = Value.filteredUnion(() => [])({ name: "a", required: false }, variantForC);
const valueB = Value.text({
    name: "a",
    required: false,
});
const test = Config.of({
    a: valueA,
    b: valueB,
    c: valueC,
});
