import { ValueSpecUnion } from "../configTypes";
import { LazyBuild, Config } from "./config";
import { Parser } from "ts-matches";
/**
 * Used in the the Value.select { @link './value.ts' }
 * to indicate the type of select variants that are available. The key for the record passed in will be the
 * key to the tag.id in the Value.select
```ts
 
export const disabled = Config.of({});
export const size = Value.number({
  name: "Max Chain Size",
  default: 550,
  description: "Limit of blockchain size on disk.",
  warning: "Increasing this value will require re-syncing your node.",
  required: true,
  range: "[550,1000000)",
  integral: true,
  units: "MiB",
  placeholder: null,
});
export const automatic = Config.of({ size: size });
export const size1 = Value.number({
  name: "Failsafe Chain Size",
  default: 65536,
  description: "Prune blockchain if size expands beyond this.",
  warning: null,
  required: true,
  range: "[550,1000000)",
  integral: true,
  units: "MiB",
  placeholder: null,
});
export const manual = Config.of({ size: size1 });
export const pruningSettingsVariants = Variants.of({
  disabled: { name: "Disabled", spec: disabled },
  automatic: { name: "Automatic", spec: automatic },
  manual: { name: "Manual", spec: manual },
});
export const pruning = Value.union(
  {
    name: "Pruning Settings",
    description:
      '- Disabled: Disable pruning\n- Automatic: Limit blockchain size on disk to a certain number of megabytes\n- Manual: Prune blockchain with the "pruneblockchain" RPC\n',
    warning: null,
    required: true,
    default: "disabled",
  },
  pruningSettingsVariants
);
```
 */
export declare class Variants<Type, WD> {
    build: LazyBuild<WD, ValueSpecUnion["variants"]>;
    validator: Parser<unknown, Type>;
    private constructor();
    static of<VariantValues extends {
        [K in string]: {
            name: string;
            spec: Config<any, any> | Config<any, never>;
        };
    }>(a: VariantValues): Variants<{ [K in keyof VariantValues]: {
        unionSelectKey: K;
        unionValueKey: VariantValues[K]["spec"] extends Config<infer B extends Record<string, any>, any> | Config<infer B extends Record<string, any>, never> ? B : never;
    }; }[keyof VariantValues], { [K_1 in keyof VariantValues]: VariantValues[K_1] extends Config<any, infer C> ? C : never; }[keyof VariantValues]>;
    /**
     * Use this during the times that the input needs a more specific type.
     * Used in types that the value/ variant/ list/ config is constructed somewhere else.
    ```ts
    const a = Config.text({
      name: "a",
      required: false,
    })
  
    return Config.of<WrapperData>()({
      myValue: a.withWrapperData(),
    })
    ```
     */
    withWrapperData<NewWrapperData extends WD extends never ? any : WD>(): Variants<Type, NewWrapperData>;
}
