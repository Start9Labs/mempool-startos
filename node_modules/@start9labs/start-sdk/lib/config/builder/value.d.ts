import { Config, LazyBuild } from "./config";
import { List } from "./list";
import { Variants } from "./variants";
import { Pattern, ValueSpec, ValueSpecDatetime, ValueSpecText } from "../configTypes";
import { DefaultString } from "../configTypes";
import { Parser } from "ts-matches";
type RequiredDefault<A> = false | {
    default: A | null;
};
type AsRequired<Type, MaybeRequiredType> = MaybeRequiredType extends {
    default: unknown;
} | never ? Type : Type | null | undefined;
/**
 * A value is going to be part of the form in the FE of the OS.
 * Something like a boolean, a string, a number, etc.
 * in the fe it will ask for the name of value, and use the rest of the value to determine how to render it.
 * While writing with a value, you will start with `Value.` then let the IDE suggest the rest.
 * for things like string, the options are going to be in {}.
 * Keep an eye out for another config builder types as params.
 * Note, usually this is going to be used in a `Config` {@link Config} builder.
 ```ts
const username = Value.string({
  name: "Username",
  default: "bitcoin",
  description: "The username for connecting to Bitcoin over RPC.",
  warning: null,
  required: true,
  masked: true,
  placeholder: null,
  pattern: "^[a-zA-Z0-9_]+$",
  patternDescription: "Must be alphanumeric (can contain underscore).",
});
 ```
 */
export declare class Value<Type, WD> {
    build: LazyBuild<WD, ValueSpec>;
    validator: Parser<unknown, Type>;
    private constructor();
    static toggle(a: {
        name: string;
        description?: string | null;
        warning?: string | null;
        default?: boolean | null;
        /**  Immutable means it can only be configed at the first config then never again
        Default is false */
        immutable?: boolean;
    }): Value<boolean, never>;
    static dynamicToggle<WD = never>(a: LazyBuild<WD, {
        name: string;
        description?: string | null;
        warning?: string | null;
        default?: boolean | null;
        disabled?: false | string;
    }>): Value<boolean, WD>;
    static text<Required extends RequiredDefault<DefaultString>>(a: {
        name: string;
        description?: string | null;
        warning?: string | null;
        required: Required;
        /** Default = false */
        masked?: boolean;
        placeholder?: string | null;
        minLength?: number | null;
        maxLength?: number | null;
        patterns?: Pattern[];
        /** Default = 'text' */
        inputmode?: ValueSpecText["inputmode"];
        /**  Immutable means it can only be configed at the first config then never again
        Default is false */
        immutable?: boolean;
    }): Value<AsRequired<string, Required>, never>;
    static dynamicText<WD = never>(getA: LazyBuild<WD, {
        name: string;
        description?: string | null;
        warning?: string | null;
        required: RequiredDefault<DefaultString>;
        /** Default = false */
        masked?: boolean;
        placeholder?: string | null;
        minLength?: number | null;
        maxLength?: number | null;
        patterns?: Pattern[];
        /** Default = 'text' */
        inputmode?: ValueSpecText["inputmode"];
    }>): Value<string | null | undefined, WD>;
    static textarea(a: {
        name: string;
        description?: string | null;
        warning?: string | null;
        required: boolean;
        minLength?: number | null;
        maxLength?: number | null;
        placeholder?: string | null;
        /**  Immutable means it can only be configed at the first config then never again
        Default is false */
        immutable?: boolean;
    }): Value<string, never>;
    static dynamicTextarea<WD = never>(getA: LazyBuild<WD, {
        name: string;
        description?: string | null;
        warning?: string | null;
        required: boolean;
        minLength?: number | null;
        maxLength?: number | null;
        placeholder?: string | null;
        disabled?: false | string;
    }>): Value<string, WD>;
    static number<Required extends RequiredDefault<number>>(a: {
        name: string;
        description?: string | null;
        warning?: string | null;
        required: Required;
        min?: number | null;
        max?: number | null;
        /** Default = '1' */
        step?: string | null;
        integer: boolean;
        units?: string | null;
        placeholder?: string | null;
        /**  Immutable means it can only be configed at the first config then never again
        Default is false */
        immutable?: boolean;
    }): Value<AsRequired<number, Required>, never>;
    static dynamicNumber<WD = never>(getA: LazyBuild<WD, {
        name: string;
        description?: string | null;
        warning?: string | null;
        required: RequiredDefault<number>;
        min?: number | null;
        max?: number | null;
        /** Default = '1' */
        step?: string | null;
        integer: boolean;
        units?: string | null;
        placeholder?: string | null;
        disabled?: false | string;
    }>): Value<number | null | undefined, WD>;
    static color<Required extends RequiredDefault<string>>(a: {
        name: string;
        description?: string | null;
        warning?: string | null;
        required: Required;
        /**  Immutable means it can only be configed at the first config then never again
        Default is false */
        immutable?: boolean;
    }): Value<AsRequired<string, Required>, never>;
    static dynamicColor<WD = never>(getA: LazyBuild<WD, {
        name: string;
        description?: string | null;
        warning?: string | null;
        required: RequiredDefault<string>;
        disabled?: false | string;
    }>): Value<string | null | undefined, WD>;
    static datetime<Required extends RequiredDefault<string>>(a: {
        name: string;
        description?: string | null;
        warning?: string | null;
        required: Required;
        /** Default = 'datetime-local' */
        inputmode?: ValueSpecDatetime["inputmode"];
        min?: string | null;
        max?: string | null;
        step?: string | null;
        /**  Immutable means it can only be configed at the first config then never again
        Default is false */
        immutable?: boolean;
    }): Value<AsRequired<string, Required>, never>;
    static dynamicDatetime<WD = never>(getA: LazyBuild<WD, {
        name: string;
        description?: string | null;
        warning?: string | null;
        required: RequiredDefault<string>;
        /** Default = 'datetime-local' */
        inputmode?: ValueSpecDatetime["inputmode"];
        min?: string | null;
        max?: string | null;
        step?: string | null;
        disabled?: false | string;
    }>): Value<string | null | undefined, WD>;
    static select<Required extends RequiredDefault<string>, B extends Record<string, string>>(a: {
        name: string;
        description?: string | null;
        warning?: string | null;
        required: Required;
        values: B;
        /**  Immutable means it can only be configed at the first config then never again
        Default is false */
        immutable?: boolean;
    }): Value<AsRequired<keyof B, Required>, never>;
    static dynamicSelect<WD = never>(getA: LazyBuild<WD, {
        name: string;
        description?: string | null;
        warning?: string | null;
        required: RequiredDefault<string>;
        values: Record<string, string>;
        disabled?: false | string;
    }>): Value<string | null | undefined, WD>;
    static multiselect<Values extends Record<string, string>>(a: {
        name: string;
        description?: string | null;
        warning?: string | null;
        default: string[];
        values: Values;
        minLength?: number | null;
        maxLength?: number | null;
        /**  Immutable means it can only be configed at the first config then never again
        Default is false */
        immutable?: boolean;
    }): Value<(keyof Values)[], never>;
    static dynamicMultiselect<WD = never>(getA: LazyBuild<WD, {
        name: string;
        description?: string | null;
        warning?: string | null;
        default: string[];
        values: Record<string, string>;
        minLength?: number | null;
        maxLength?: number | null;
        disabled?: false | string;
    }>): Value<string[], WD>;
    static object<Type extends Record<string, any>, WrapperData>(a: {
        name: string;
        description?: string | null;
        warning?: string | null;
    }, previousSpec: Config<Type, WrapperData>): Value<Type, WrapperData>;
    static union<Required extends RequiredDefault<string>, Type, WrapperData>(a: {
        name: string;
        description?: string | null;
        warning?: string | null;
        required: Required;
        default?: string | null;
        /**  Immutable means it can only be configed at the first config then never again
        Default is false */
        immutable?: boolean;
    }, aVariants: Variants<Type, WrapperData>): Value<AsRequired<Type, Required>, WrapperData>;
    static filteredUnion<WrapperData = never>(getDisabledFn: LazyBuild<WrapperData, string[]>): <Required_1 extends RequiredDefault<string>, Type extends Record<string, any>>(a: {
        name: string;
        description?: string | null | undefined;
        warning?: string | null | undefined;
        required: Required_1;
        default?: string | null | undefined;
    }, aVariants: Variants<Type, WrapperData> | Variants<Type, never>) => Value<AsRequired<Type, Required_1>, WrapperData>;
    static list<Type, WrapperData>(a: List<Type, WrapperData>): Value<Type, WrapperData>;
    /**
     * Use this during the times that the input needs a more specific type.
     * Used in types that the value/ variant/ list/ config is constructed somewhere else.
    ```ts
    const a = Config.text({
      name: "a",
      required: false,
    })
  
    return Config.of<WrapperData>()({
      myValue: a.withWrapperData(),
    })
    ```
     */
    withWrapperData<NewWrapperData extends WD extends never ? any : WD>(): Value<Type, NewWrapperData>;
}
export {};
