import { Config, LazyBuild } from "./config";
import { ListValueSpecText, Pattern, UniqueBy, ValueSpecList } from "../configTypes";
import { Parser } from "ts-matches";
/**
 * Used as a subtype of Value.list
```ts
export const authorizationList = List.string({
  "name": "Authorization",
  "range": "[0,*)",
  "default": [],
  "description": "Username and hashed password for JSON-RPC connections. RPC clients connect using the usual http basic authentication.",
  "warning": null
}, {"masked":false,"placeholder":null,"pattern":"^[a-zA-Z0-9_-]+:([0-9a-fA-F]{2})+\\$([0-9a-fA-F]{2})+$","patternDescription":"Each item must be of the form \"<USERNAME>:<SALT>$<HASH>\"."});
export const auth = Value.list(authorizationList);
```
*/
export declare class List<Type, WD> {
    build: LazyBuild<WD, ValueSpecList>;
    validator: Parser<unknown, Type>;
    private constructor();
    static text(a: {
        name: string;
        description?: string | null;
        warning?: string | null;
        /** Default = [] */
        default?: string[];
        minLength?: number | null;
        maxLength?: number | null;
    }, aSpec: {
        /** Default = false */
        masked?: boolean;
        placeholder?: string | null;
        minLength?: number | null;
        maxLength?: number | null;
        patterns: Pattern[];
        /** Default = "text" */
        inputmode?: ListValueSpecText["inputmode"];
    }): List<string[], never>;
    static dynamicText<WD = never>(getA: LazyBuild<WD, {
        name: string;
        description?: string | null;
        warning?: string | null;
        /** Default = [] */
        default?: string[];
        minLength?: number | null;
        maxLength?: number | null;
        disabled?: false | string;
        spec: {
            /** Default = false */
            masked?: boolean;
            placeholder?: string | null;
            minLength?: number | null;
            maxLength?: number | null;
            patterns: Pattern[];
            /** Default = "text" */
            inputmode?: ListValueSpecText["inputmode"];
        };
    }>): List<string[], WD>;
    static number(a: {
        name: string;
        description?: string | null;
        warning?: string | null;
        /** Default = [] */
        default?: string[];
        minLength?: number | null;
        maxLength?: number | null;
    }, aSpec: {
        integer: boolean;
        min?: number | null;
        max?: number | null;
        step?: string | null;
        units?: string | null;
        placeholder?: string | null;
    }): List<number[], never>;
    static dynamicNumber<WD = never>(getA: LazyBuild<WD, {
        name: string;
        description?: string | null;
        warning?: string | null;
        /** Default = [] */
        default?: string[];
        minLength?: number | null;
        maxLength?: number | null;
        disabled?: false | string;
        spec: {
            integer: boolean;
            min?: number | null;
            max?: number | null;
            step?: string | null;
            units?: string | null;
            placeholder?: string | null;
        };
    }>): List<number[], WD>;
    static obj<Type extends Record<string, any>, WrapperData>(a: {
        name: string;
        description?: string | null;
        warning?: string | null;
        /** Default [] */
        default?: [];
        minLength?: number | null;
        maxLength?: number | null;
    }, aSpec: {
        spec: Config<Type, WrapperData>;
        displayAs?: null | string;
        uniqueBy?: null | UniqueBy;
    }): List<Type[], WrapperData>;
    /**
     * Use this during the times that the input needs a more specific type.
     * Used in types that the value/ variant/ list/ config is constructed somewhere else.
    ```ts
    const a = Config.text({
      name: "a",
      required: false,
    })
  
    return Config.of<WrapperData>()({
      myValue: a.withWrapperData(),
    })
    ```
     */
    withWrapperData<NewWrapperData extends WD extends never ? any : WD>(): List<Type, NewWrapperData>;
}
