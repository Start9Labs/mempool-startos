import { Config, ExtractConfigType } from "../config/builder/config";
import { ActionMetaData, ActionResult, Effects, ExportedAction } from "../types";
import { Utils } from "../util";
export declare class CreatedAction<WrapperData, ConfigType extends Record<string, any> | Config<any, WrapperData> | Config<any, never>, Type extends Record<string, any> = ExtractConfigType<ConfigType>> {
    readonly myMetaData: ActionMetaData;
    readonly fn: (options: {
        effects: Effects;
        utils: Utils<WrapperData>;
        input: Type;
    }) => Promise<ActionResult>;
    readonly input: Config<Type, WrapperData> | Config<Type, never>;
    private constructor();
    validator: import("ts-matches").Validator<unknown, Type>;
    static of<WrapperData, ConfigType extends Record<string, any> | Config<any, any> | Config<any, never>, Type extends Record<string, any> = ExtractConfigType<ConfigType>>(metaData: Omit<ActionMetaData, "input"> & {
        input: Config<Type, WrapperData> | Config<Type, never>;
    }, fn: (options: {
        effects: Effects;
        utils: Utils<WrapperData>;
        input: Type;
    }) => Promise<ActionResult>): CreatedAction<WrapperData, ConfigType, Type>;
    exportedAction: ExportedAction;
    run: ({ effects, input }: {
        effects: Effects;
        input?: Type | undefined;
    }) => Promise<ActionResult>;
    getConfig({ effects }: {
        effects: Effects;
    }): Promise<{ [K in keyof Type]: import("../config/configTypes").ValueSpec; }>;
}
export declare const createAction: typeof CreatedAction.of;
